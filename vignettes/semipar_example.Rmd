---
title: "Semiparametric Estimation with Hospital Discharge Data"
author: "Matthew T. Panhans"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Semiparametric Estimation with Hospital Discharge Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette shows how to use healthcare.antitrust to implement semiparametric demand estimation of hospital discharge data.

# Cell definitions
The first step is to assign observations to 'cells' within which the substitution proportional to share is assumed to hold. This can be done with the `cell_defn` function. Begin by loading the example simulation dataset of hospital discharges:

```{r}
library(healthcare.antitrust)
data(discharge_data, package = "healthcare.antitrust")
```

This simulated dataset contains hospital discharges, with each observation including a hospital identifier and patient characteristics (DRG diagnosis code, patient age, and patient zip code of residence).

The observations will be grouped into cells based on variables in the dataset. Let's define cells based on three variables: the DRG diagnosis code, the patient age, and the patient zip code of residence.

```{r}
list1 <- c("drg","age","zip5")
layers <- list(list1)
```

A minimum cell size threshold also needs to be set. Let's set the minimum size to 15:
```{r}
th <- 15
```

Then use `cell_defn` to allocate observations to cells, based on the variables in the layer. The one required variable is `adm`, which indicates how many admissions are represented by each observation. In this case, each observation is an admission, so we will set adm to 1 for all observations. Then we can run `cell_defn`.
```{r}
discharge_data$adm <- 1
outList <- cell_defn(discharge_data,th,layers)
```

The `cell_defn` function returns a list. The first item in the list is a new dataset that contains the observations that have been allocated to a cell.

```{r}
D0 <- outList$dataset
print(nrow(D0))
print(nrow(discharge_data))
```

The new dataset has `nrow(D0)` observations. `cell_defn` stated that it excluded some observations, those that were not allocated to a cell that met the minimum size threshold. The number of excluded observations added to the number of observations in the new dataset equals the number of observations in the original dataset. 

We can instead use two layers to define cells. Adding a second, more coarse, layer will allow more observations to be allocated to cells that meet the minimum size threshold. Let's add layers that use three digit zip code. 

```{r}
discharge_data$zip3 <- floor(discharge_data$zip5/100)
list2 <- c("drg","age","zip5")
list3 <- c("drg","age","zip3")
list4 <- c("zip3")
layers <- list(list2, list4, list3)
```

With this new definition of layers, we can allocate observations like before:

```{r}
outList <- cell_defn(discharge_data,th,layers)
D0 <- outList$dataset
print(nrow(D0))
print(nrow(discharge_data))
```

The observations are first allocated to cells as before, and the remaining observations are allocated to a cell based on three digit zip code only. With these definitions, every observation is allocated to a cell that meets the minimum size threshold that was set.

We are now able to calculate diversion ratios based on the cell definitions.

# Diversion ratio calculation

We can calculate diversion ratios with the function `div_calc`. The required variables are `cell`, which has been defined by the `cell_defn` function, as well as hospital and system identifiers: `hosp_id`,`Hospital`,`sys_id`, and `System`. The function also requires `adm`, which is created by `cell_defn` if it does not exist.

Finally, we need to specify an indicator for whether a hospital is a merging party; the variable to do so is `party_ind`, and these are the hospitals for which diversion ratios will be calculated. Suppose hospitals 1, 2, and 5 are merging.

```{r}
D0$party_ind <- 0
D0$party_ind[D0$hosp_id==1] <- 1
D0$party_ind[D0$hosp_id==2] <- 1
D0$party_ind[D0$hosp_id==5] <- 1
```

Now we can calculate diversions using the `div_calc` function.

```{r}
out <- div_calc(D0)
```

The function prints the `hosp_id` of each hospital for which diversion is calculated. If the total diversion for a given hospital does not sum to 1, that means that a degenerate cell exists and the `dropDegenerateCell` was set to `FALSE`. A notification flag will be printed whenever a degenerate cell exists for a given hospital.

The function `div_calc` outputs two objects, a matrix of hospital-level diversions and a matrix aggregated to system-level diversions. The hospital-level matrix gives diversions from each of the merging hospitals to all other hospitals. The diversions should sum to 1. We can verify that our diversions sum to one for Hospital 1:

```{r}
divratio_hosp <- out$hosp_level
sum(divratio_hosp$div_from_1, na.rm = TRUE)
```

We can also print the hospital-level and system-level diversions.

```{r}
print(out$hosp_level)
print(out$sys_level)
```


# Willingness-to-pay calculation

The function `wtp_calc` can be used to calculate the willingness-to-pay (WTP) of a hospital system. This can be used to estimate the change in WTP that would occur after a merger, using the same data as before. The primary difference, is that `wtp_calc` will expect to find a variable `weight`; this variable is required because WTP calculations for hospitals sometimes involve weighting by DRG weights. If an equal weighting is desired for all observations, this variable can be set to 1.

```{r}
D0$weight <- 1

out <- wtp_calc(D0)
y_pre <- subset(out, party == 1)

D0_post <- D0
D0_post$sys_id[D0_post$party_ind == 1] <- 1

out <- wtp_calc(D0_post)
y_post <- subset(out, party == 1)

y_pre <- aggregate(list(WTP_s = y_pre$WTP_s, WTP_s_wt = y_pre$WTP_s_wt, N_s=y_pre$N_s),by=list(y_party=y_pre$party),sum)

print("% Change in WTP")
print((y_post$WTP_s-y_pre$WTP_s)/(y_pre$WTP_s)*100)
```
